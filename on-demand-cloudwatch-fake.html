<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WCU 24h Chart</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 0;
    }
    #chart-container {
      width: 100%;
      height: 400px;
    }
  </style>
</head>
<body>
<div id="chart-container">
  <canvas id="wcuChart"></canvas>
</div>

<script>
  const labels = [];
  for (let i = 0; i < 1440; i++) {
    // Generate timestamps starting at 18:00
    const minuteOfDay = (18 * 60 + i) % 1440;
    const hour = Math.floor(minuteOfDay / 60);
    const minute = minuteOfDay % 60;
    const timeLabel = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
    labels.push(timeLabel);
  }

  function generateCapacitySeries({
    seedOffset = 0,
    scale = 1.0,
    shapeFn = null
  } = {}) {
    const series = [];
    for (let i = 0; i < 1440; i++) {
      const minuteOfDay = (18 * 60 + i) % 1440;
      const seed = i + seedOffset;

      let value = 0;

      value = shapeFn ? shapeFn(minuteOfDay, seed) : 0;

      series.push(Math.round(value * scale));
    }
    return series;
  }

  // Generate data
  const rcuPoints = generateCapacitySeries({
    shapeFn: (minuteOfDay, seed) => {
      const hour = Math.floor(minuteOfDay / 60);
      const minute = minuteOfDay % 60;
      const time = hour + minute / 60;

      let base = 0;

      if (time >= 6 && time < 9) {
        // Exponential ramp-up from 6am to 9am
        const progress = (time - 6) / 3; // normalized between 0 and 1
        base = 10000 + Math.pow(progress, 2.5) * 150000;
      } else if (time >= 9 && time < 17) {
        // Business hours: variable load with controlled ceiling
        const hoursSince9 = time - 9;
        const lunchWave = Math.sin(hoursSince9 * Math.PI / 4); // peak ~12
        const afternoonWave = Math.cos(hoursSince9 * Math.PI / 6); // dip ~14–15
        const variation = lunchWave * 10000 + afternoonWave * 1000;
        base = 75000 + variation + Math.sin(seed / 8) * 5000 + Math.random() * 3000;
        base = Math.min(base, 110000); // cap to stay under 9am peak
      } else if (time >= 17 && time < 20) {
        // Post-work write bursts with random plateaus
        base = 50000 + (seed % 60 < 30 ? 15000 : 10000) + Math.random() * 5000;
      } else if (time >= 20 && time < 22) {
        // Evening taper with jitter
        base = 25000 - ((time - 20) / 2) * 10000 + Math.random() * 3000;
      } else {
        // Overnight flat low with minor jitter
        base = 10000 + Math.random() * 2000;
      }

      return base + Math.random() * 5000;
    }
  });

  const wcuPoints = generateCapacitySeries({
    seedOffset: 1440,
    shapeFn: (minuteOfDay, seed) => {
      const hour = Math.floor(minuteOfDay / 60);
      const minute = minuteOfDay % 60;
      const time = hour + minute / 60;

      let base = 0;

      // Simulate weekday-style traffic
      if (time >= 6 && time < 9) {
        // Morning ramp-up
        base = 5000 + ((time - 6) / 3) * 20000;
      } else if (time >= 9 && time < 17) {
        // Daytime plateau with some fluctuation
        base = 25000 + Math.sin(seed / 10) * 3000;
      } else if (time >= 17 && time < 20) {
        // Early evening dip
        base = 15000 + Math.sin(seed / 12) * 2000;
      } else if (time >= 20 && time < 22) {
        // Post-dinner mini bump
        base = 18000 + Math.sin(seed / 8) * 2500;
      } else {
        // Late night/early morning low
        base = 7000 + Math.sin(seed / 16) * 1000;
      }

      // Add some noise
      return base + Math.random() * 2000;
    }
  });

// WCU stats
const totalWCU = wcuPoints.reduce((sum, value) => sum + value, 0);
const averageWCU = totalWCU / wcuPoints.length;
const peakWCU = Math.max(...wcuPoints);
const thresholdWCU = peakWCU * 0.9;
const peakMinutesWCU = wcuPoints.filter(v => v >= thresholdWCU).length;
const peakDurationWCU = (peakMinutesWCU / 60).toFixed(1);

// RCU stats
const totalRCU = rcuPoints.reduce((sum, value) => sum + value, 0);
const averageRCU = totalRCU / rcuPoints.length;
const peakRCU = Math.max(...rcuPoints);
const thresholdRCU = peakRCU * 0.9;
const peakMinutesRCU = rcuPoints.filter(v => v >= thresholdRCU).length;
const peakDurationRCU = (peakMinutesRCU / 60).toFixed(1);

// Display stats in HTML
const statsDiv = document.createElement('div');
statsDiv.style.padding = '1rem';
statsDiv.style.fontFamily = 'Roboto, Arial, sans-serif';
statsDiv.innerHTML = `
  <table style="border-collapse: collapse; font-size: 14px;">
    <thead>
      <tr>
        <th style="text-align: left; padding: 4px 12px; border-bottom: 2px solid #ccc;">Metric</th>
        <th style="text-align: left; padding: 4px 12px; border-bottom: 2px solid #ccc;">WCU</th>
        <th style="text-align: left; padding: 4px 12px; border-bottom: 2px solid #ccc;">RCU</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="padding: 4px 12px;">Average</td>
        <td style="padding: 4px 12px;">${Math.round(averageWCU).toLocaleString()}</td>
        <td style="padding: 4px 12px;">${Math.round(averageRCU).toLocaleString()}</td>
      </tr>
      <tr>
        <td style="padding: 4px 12px;">Peak</td>
        <td style="padding: 4px 12px;">${peakWCU.toLocaleString()}</td>
        <td style="padding: 4px 12px;">${peakRCU.toLocaleString()}</td>
      </tr>
      <tr>
        <td style="padding: 4px 12px;">Peak Duration (≥90%)</td>
        <td style="padding: 4px 12px;">${peakDurationWCU} hours</td>
        <td style="padding: 4px 12px;">${peakDurationRCU} hours</td>
      </tr>
    </tbody>
  </table>
`;
document.body.insertBefore(statsDiv, document.getElementById('chart-container'));

  const ctx = document.getElementById('wcuChart').getContext('2d');

  new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [
        {
          label: 'Write Capacity Units',
          data: wcuPoints,
          borderColor: '#f57a16',
          backgroundColor: '#f57a16',
          tension: 0.1,
          fill: false,
          pointRadius: 0,
          borderWidth: 2
        },
        {
          label: 'Read Capacity Units',
          data: rcuPoints,
          borderColor: '#2073ad',
          backgroundColor: '#2073ad',
          tension: 0.1,
          fill: false,
          pointRadius: 0,
          borderWidth: 2
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          display: true,
          position: 'bottom',
          align: 'start',
          labels: {
            usePointStyle: true,
            pointStyle: 'rectRounded',

          }
        }
      },
      scales: {
        x: {
          ticks: {
            autoSkip: false,
            maxRotation: 0,
            minRotation: 0,
            callback: function(value, index) {
              return index % 180 === 0 ? this.getLabelForValue(value) : '';
            }
          },
          grid: { display: false }
        },
        y: {
          beginAtZero: true,
          grid: {
            display: true,
            drawBorder: false,
            drawTicks: false,
            color: function(context) {
              return context.tick.value % 10000 === 0 ? '#e0e0e0' : 'transparent';
            }
          },
          ticks: {
            color: '#000',
            callback: function(value) {
              return value.toLocaleString();
            }
          }
        }
      },
      animation: false
    }
  });
</script>
</body>
</html>